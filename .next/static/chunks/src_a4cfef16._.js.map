{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///Users/edwin/Desktop/CSCI3100_Project/src/components/navigation/BackButton.tsx"],"sourcesContent":["\"use client\";\n\nimport { faChevronLeft } from \"@fortawesome/free-solid-svg-icons\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { useRouter, usePathname } from \"next/navigation\";\n\nexport default function BackButton() {\n  const router = useRouter();\n  const pathname = usePathname();\n  const shouldHide =\n    pathname?.includes(\"/forum/latest\") ||\n    pathname?.includes(\"/forum/recommended\") ||\n    pathname?.includes(\"/forum/search-results\") ||\n    pathname?.includes(\"/forum/following\");\n\n  if (shouldHide) return null;\n\n  return (\n    <button onClick={() => router.back()} className=\"btn btn-circle btn-lg bg-base-100\">\n      <FontAwesomeIcon icon={faChevronLeft} className=\"w-4 h-4\" />\n    </button>\n  );\n}\n"],"names":[],"mappings":";;;;AAEA;AACA;AACA;;;AAJA;;;;AAMe,SAAS;;IACtB,MAAM,SAAS,CAAA,GAAA,qIAAA,CAAA,YAAS,AAAD;IACvB,MAAM,WAAW,CAAA,GAAA,qIAAA,CAAA,cAAW,AAAD;IAC3B,MAAM,aACJ,UAAU,SAAS,oBACnB,UAAU,SAAS,yBACnB,UAAU,SAAS,4BACnB,UAAU,SAAS;IAErB,IAAI,YAAY,OAAO;IAEvB,qBACE,6LAAC;QAAO,SAAS,IAAM,OAAO,IAAI;QAAI,WAAU;kBAC9C,cAAA,6LAAC,uKAAA,CAAA,kBAAe;YAAC,MAAM,2KAAA,CAAA,gBAAa;YAAE,WAAU;;;;;;;;;;;AAGtD;GAhBwB;;QACP,qIAAA,CAAA,YAAS;QACP,qIAAA,CAAA,cAAW;;;KAFN","debugId":null}},
    {"offset": {"line": 61, "column": 0}, "map": {"version":3,"sources":["file:///Users/edwin/Desktop/CSCI3100_Project/src/utils/posts.ts"],"sourcesContent":["\"use server\";\n\nimport { getSession } from \"@/utils/sessions\";\n\nexport interface Post {\n  postId: string;\n  userId: string;\n  username: string;\n  avatar: string | null;\n  isUserBlocked: boolean;\n  title: string;\n  content: string;\n  imageAPIList: string[] | null;\n  tagNameList: string[] | null;\n  likeCount: number;\n  isLiked: boolean;\n  dislikeCount: number;\n  isDisliked: boolean;\n  commentCount: number;\n  updatedAt: string;\n  commentList: Post[] | null;\n}\n\n// API response type for getPost\ninterface PostPreviewResponse {\n  message: string;\n  data: {\n    isSuccess: boolean;\n    postPreviewList: Post[];\n  };\n}\n\ninterface PostContentResponse {\n  message: string;\n  data: {\n    isSuccess: boolean;\n    post: Post;\n  };\n}\n\nexport interface Tag {\n  tagId: string;\n  tagName: string;\n}\n\ninterface TagResponse {\n  message: string;\n  data: {\n    isSuccess: boolean;\n    tagList: Tag[];\n  };\n}\n\ninterface CreatePostResponse {\n  message: string;\n  data: {\n    isSuccess: boolean;\n  };\n}\n\nexport async function getAllTags(): Promise<Tag[]> {\n  try {\n    const session = await getSession();\n    const apiUrl = `https://flowchatbackend.azurewebsites.net/api/Forum/getAllTag`;\n\n    // Fetch data from the API\n    const response = await fetch(apiUrl, {\n      headers: {\n        Authorization: `Bearer ${session.token}`,\n      },\n    });\n\n    // If API call fails, use mock data\n    if (!response.ok) {\n      console.log(`Mock tags are returned due to API request failed with status ${response.status}`);\n      return [];\n    }\n\n    const data: TagResponse = await response.json();\n\n    return data.data.tagList;\n  } catch (error) {\n    console.error(\"Error fetching tags:\", error);\n    return [];\n  }\n}\n\n// sample API call\n// https://flowchatbackend.azurewebsites.net/api/Forum/\n// getLatestPostPreviewList?\n// userId=1\n// &excludingPostIdList=1\n// &excludingPostIdList=34\n// &postNum=5\nexport async function getPosts(\n  options: {\n    filter?: \"latest\" | \"recommended\" | \"following\" | \"created\";\n    excludingPostIdList?: number[];\n    count?: number;\n    authorUserId?: string;\n  } = {}\n): Promise<Post[] | null> {\n  try {\n    const session = await getSession();\n    // Build the API URL based on the filter\n    let apiUrl = \"https://flowchatbackend.azurewebsites.net/api/Forum/\";\n    switch (options.filter) {\n      case \"latest\":\n        apiUrl += `getLatestPostPreviewList?`;\n        break;\n      case \"recommended\":\n        apiUrl += \"getRecommendedPostPreviewList?\";\n        break;\n      case \"following\":\n        apiUrl += \"getFollowingPostPreviewList?\";\n        break;\n      case \"created\":\n        apiUrl = \"https://flowchatbackend.azurewebsites.net/api/Profile/getMyPostPreviewList?\";\n        break;\n    }\n\n    // Add query parameters\n    switch (options.filter) {\n      case \"created\":\n        apiUrl += `userIdFrom=${session.userId}`;\n        if (options.authorUserId === \"0\") {\n          apiUrl += `&userIdTo=${session.userId}`\n        } else {\n          apiUrl += `&userIdTo=${options.authorUserId}`\n        }\n        break;\n      default:\n        apiUrl += `userId=${session.userId}`; // Add userId to the URL\n        break;\n    }\n    \n\n    if (options.excludingPostIdList) {\n      while (options.excludingPostIdList.length > 0) {\n        //add all excludingPostIds to the URL\n        apiUrl += `&excludingPostIdList=${options.excludingPostIdList.shift()}`;\n      }\n    } else {\n      //default value = 0\n      apiUrl += `&excludingPostIdList=0`;\n    }\n\n    apiUrl += `&postNum=${options.count || 10}`;\n\n    // Fetch data from the API\n    const response = await fetch(apiUrl, {\n      method: \"GET\",\n      headers: {\n        Authorization: `Bearer ${session.token}`,\n      },\n    });\n\n    const data: PostPreviewResponse = await response.json();\n    // Map API response to frontend Post interface\n    const posts: Post[] = data.data.postPreviewList.map((post) => ({\n      postId: post.postId,\n      userId: post.userId,\n      username: post.username,\n      avatar: post.avatar,\n      isUserBlocked: post.isUserBlocked,\n      title: post.title,\n      content: post.content,\n      imageAPIList: post.imageAPIList,\n      tagNameList: post.tagNameList,\n      likeCount: post.likeCount,\n      isLiked: post.isLiked,\n      dislikeCount: post.dislikeCount,\n      isDisliked: post.isDisliked,\n      commentCount: post.commentCount,\n      updatedAt: post.updatedAt,\n      commentList: post.commentList,\n    }));\n\n    return posts;\n  } catch (error) {\n    console.error(\"Error fetching posts:\", error);\n    return [];\n  }\n}\n\n// Sample API call:\n// https://flowchatbackend.azurewebsites.net/api/Forum/\n// searchPost?\n// userId=1&\n// keyword=prog&\n// excludingPostIdList=23&\n// excludingPostIdList=24&\n// searchNum=10\nexport async function getSearchPosts(\n  options: {\n    keyword?: string;\n    tagIdList?: number[];\n    excludingPostIdList?: number[];\n    count?: number;\n  } = {}\n): Promise<Post[] | null> {\n  try {\n    const session = await getSession();\n\n    let apiUrl = `https://flowchatbackend.azurewebsites.net/api/Forum/searchPost?`;\n\n    // Add query parameters\n    apiUrl += `userId=${session.userId}`; // Add userId to the URL\n\n    // Add keyword if provided\n    if (options.keyword) {\n      apiUrl += `&keyword=${options.keyword}`;\n    }\n\n    if (options.excludingPostIdList) {\n      const idList = [...options.excludingPostIdList]; // Create a copy to prevent mutation\n      idList.forEach((id) => {\n        apiUrl += `&excludingPostIdList=${id}`;\n      });\n    } else {\n      //default value = 0\n      apiUrl += `&excludingPostIdList=0`;\n    }\n\n    apiUrl += `&postNum=${options.count || 10}`;\n\n    // Fetch data from the API\n    const response = await fetch(apiUrl, {\n      method: \"GET\",\n      headers: {\n        Authorization: `Bearer ${session.token}`,\n      },\n    });\n\n    if (!response.ok) {\n      console.error(`Failed to fetch search posts with status ${response.status}`);\n      return null;\n    }\n\n    const data: PostPreviewResponse = await response.json();\n\n    // Map API response to frontend Post interface\n    const posts: Post[] = data.data.postPreviewList.map((post) => ({\n      postId: post.postId,\n      userId: post.userId,\n      username: post.username,\n      avatar: post.avatar,\n      isUserBlocked: post.isUserBlocked,\n      title: post.title,\n      content: post.content,\n      imageAPIList: post.imageAPIList,\n      tagNameList: post.tagNameList,\n      likeCount: post.likeCount,\n      isLiked: post.isLiked,\n      dislikeCount: post.dislikeCount,\n      isDisliked: post.isDisliked,\n      commentCount: post.commentCount,\n      updatedAt: post.updatedAt,\n      commentList: post.commentList,\n    }));\n\n    return posts;\n  } catch (error) {\n    console.error(\"Error fetching posts:\", error);\n    return null;\n  }\n}\n\nexport async function getPostById(postId: string): Promise<Post | null> {\n  try {\n    const session = await getSession();\n\n    const apiUrl = `https://flowchatbackend.azurewebsites.net/api/Forum/getPostContent?userId=${session.userId}&postId=${postId}`;\n\n    // Fetch data from the API\n    const response = await fetch(apiUrl, {\n      headers: {\n        Authorization: `Bearer ${session.token}`,\n      },\n    });\n\n    try {\n      const json = await response.json();\n      const data: PostContentResponse = json;\n      const post = data.data.post;\n      return {\n        postId: post.postId,\n        userId: post.userId,\n        username: post.username,\n        avatar: post.avatar,\n        isUserBlocked: post.isUserBlocked,\n        title: post.title,\n        content: post.content,\n        imageAPIList: post.imageAPIList,\n        tagNameList: post.tagNameList,\n        likeCount: post.likeCount,\n        isLiked: post.isLiked,\n        dislikeCount: post.dislikeCount,\n        isDisliked: post.isDisliked,\n        commentCount: post.commentCount,\n        updatedAt: post.updatedAt,\n        commentList: post.commentList,\n      };\n    } catch (error) {\n      console.error(\"Error parsing JSON response:\", error);\n      return null;\n    }\n  } catch (error) {\n    console.error(\"Error fetching post:\", error);\n    return null;\n  }\n}\n\n// Create a new post with the given title, content, tags, and images\nexport async function createPost(title: string, content: string, tags: Tag[], images: File[]): Promise<string | null> {\n  try {\n    const session = await getSession();\n\n    // Validate session\n    if (!session?.isLoggedIn || !session?.token) {\n      throw new Error(\"User is not logged in or token is unavailable\");\n    }\n\n    // Validate userId\n    const userId = parseInt(session.userId?.toString() || \"0\", 10);\n    if (isNaN(userId)) {\n      throw new Error(\"Invalid userId\");\n    }\n\n    // Construct request body for the backend\n    const requestBody = {\n      userId,\n      title,\n      content: content.replace(/<[^>]+>/g, \"\"), // Remove HTML tags from content\n      tag: tags.map((tag) => tag.tagName),\n      attachTo: 0,\n    };\n\n    // Create FormData for multipart/form-data request\n    const formData = new FormData();\n    const requestBodyBlob = new Blob([JSON.stringify(requestBody)], { type: \"application/json\" });\n    formData.append(\"requestBody\", requestBodyBlob);\n\n    // Append images to imageList if any\n    if (images.length > 0) {\n      images.forEach((image) => {\n        formData.append(\"imageList\", image);\n      });\n    }\n\n    const apiUrl = \"https://flowchatbackend.azurewebsites.net/api/Forum/createPostOrComment\";\n    const response = await fetch(apiUrl, {\n      method: \"POST\",\n      headers: {\n        Authorization: `Bearer ${session.token}`,\n      },\n      body: formData,\n    });\n\n    // Check response status\n    if (!response.ok) {\n      if (response.status === 415) {\n        throw new Error(\"Unsupported media type, please check request format\");\n      }\n      if (response.status === 401) {\n        throw new Error(\"Authentication failed, please log in again\");\n      }\n      if (response.status === 500) {\n        throw new Error(\"Server error, please contact the administrator\");\n      }\n      throw new Error(`Failed to create post, status code: ${response.status}`);\n    }\n\n    // Parse response\n    const data: CreatePostResponse = await response.json();\n    let postId: string | null = null;\n    let isSuccess: boolean = false;\n\n    // Handle different response formats\n    if (typeof data.data === \"string\") {\n      // Legacy format: data.data is a string like \"48 success: true\"\n      const dataString = data.data as string;\n      const [id, successPart] = dataString.split(\" success: \");\n      postId = id;\n      isSuccess = successPart === \"true\";\n    } else if (data.data && typeof data.data === \"object\" && \"isSuccess\" in data.data) {\n      // New format: data.data is an object like { isSuccess: true }\n      isSuccess = (data.data as { isSuccess: boolean }).isSuccess;\n      if (isSuccess) {\n        // Backend did not return postId, fetch the latest post\n        const latestPosts = await getPosts({ filter: \"latest\", count: 1 });\n        if (!latestPosts || latestPosts.length === 0) {\n          throw new Error(\"Unable to fetch the latest post for navigation\");\n        }\n        postId = latestPosts[0].postId;\n      }\n    } else {\n      throw new Error(\"Unexpected response format from backend\");\n    }\n\n    if (!isSuccess) {\n      throw new Error(data.message || \"Failed to create post\");\n    }\n\n    if (!postId) {\n      throw new Error(\"Unable to retrieve post ID for navigation\");\n    }\n\n    return postId;\n  } catch (error) {\n    throw error;\n  }\n}\n\n// Update an existing post with the given data\nexport async function updatePost(\n  postId: string,\n  title: string,\n  content: string,\n  tags: Tag[],\n  images: File[],\n  existingImages: string[]\n): Promise<string | null> {\n  try {\n    // Retrieve the current session\n    const session = await getSession();\n\n    // Validate session\n    if (!session?.isLoggedIn || !session?.token) {\n      throw new Error(\"User is not logged in or token is unavailable\");\n    }\n\n    // Validate userId\n    const userId = parseInt(session.userId?.toString() || \"0\", 10);\n    if (isNaN(userId)) {\n      throw new Error(\"Invalid userId\");\n    }\n\n    // Construct the request body, consistent with createPost\n    const requestBody = {\n      postId: parseInt(postId, 10), // Post ID to update\n      userId, // User ID of the poster\n      title, // Updated post title\n      content: content.replace(/<[^>]+>/g, \"\"), // Remove HTML tags from content\n      tag: tags.map((tag) => tag.tagName), // List of tag names\n      attachTo: 0, // Parent post ID (if applicable, set to 0 if not a comment)\n      imageAPIList: existingImages, // List of existing image URLs to retain\n    };\n\n    // Create FormData for multipart/form-data request\n    const formData = new FormData();\n    const requestBodyBlob = new Blob([JSON.stringify(requestBody)], { type: \"application/json\" });\n    formData.append(\"requestBody\", requestBodyBlob);\n\n    // If there are new images, append them to imageList\n    if (images.length > 0) {\n      images.forEach((image) => {\n        formData.append(\"imageList\", image);\n      });\n    }\n\n    // API endpoint for updating a post or comment\n    const apiUrl = \"https://flowchatbackend.azurewebsites.net/api/Forum/updatePostOrComment\";\n    const response = await fetch(apiUrl, {\n      method: \"PUT\", // Use PUT method for updating\n      headers: {\n        Authorization: `Bearer ${session.token}`, // Authorization token\n      },\n      body: formData, // FormData containing requestBody and imageList\n    });\n\n    // Check response status\n    if (!response.ok) {\n      if (response.status === 415) {\n        throw new Error(\"Unsupported media type, please check request format\");\n      }\n      if (response.status === 401) {\n        throw new Error(\"Authentication failed, please log in again\");\n      }\n      if (response.status === 500) {\n        throw new Error(\"Server error, please contact the administrator\");\n      }\n      throw new Error(`Failed to update post, status code: ${response.status}`);\n    }\n\n    // Parse the response\n    const data: CreatePostResponse = await response.json();\n    let updatedPostId: string | null = null;\n    let isSuccess: boolean = false;\n\n    // Handle different response formats, consistent with createPost\n    if (typeof data.data === \"string\") {\n      // Legacy format: data.data is a string like \"48 success: true\"\n      const dataString = data.data as string;\n      const [id, successPart] = dataString.split(\" success: \");\n      updatedPostId = id;\n      isSuccess = successPart === \"true\";\n    } else if (data.data && typeof data.data === \"object\" && \"isSuccess\" in data.data) {\n      // New format: data.data is an object like { isSuccess: true }\n      isSuccess = (data.data as { isSuccess: boolean }).isSuccess;\n      if (isSuccess) {\n        // Backend did not return postId, use the provided postId\n        updatedPostId = postId;\n      }\n    } else {\n      throw new Error(\"Unexpected response format from backend\");\n    }\n\n    // Check if the update was successful\n    if (!isSuccess) {\n      throw new Error(data.message || \"Failed to update post\");\n    }\n\n    // Ensure a post ID is available for navigation\n    if (!updatedPostId) {\n      throw new Error(\"Unable to retrieve post ID for navigation\");\n    }\n\n    return updatedPostId;\n  } catch (error) {\n    throw error;\n  }\n}\n"],"names":[],"mappings":";;;;;;IA4DsB,aAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 77, "column": 0}, "map": {"version":3,"sources":["file:///Users/edwin/Desktop/CSCI3100_Project/src/hooks/useTags.tsx"],"sourcesContent":["\"use client\";\n\nimport React, { createContext, useState, useContext } from \"react\";\nimport { Tag } from \"@/utils/posts\";\n\nexport interface TagContextType {\n  selectedTags: Tag[];\n  setSelectedTags: (tags: Tag[]) => void;\n  isPostsLoading: boolean;\n  setPostsLoading: (isLoading: boolean) => void;\n}\n\nexport const TagContext = createContext<TagContextType>({\n  selectedTags: [],\n  setSelectedTags: () => {},\n  isPostsLoading: false,\n  setPostsLoading: () => {},\n});\n\nexport function TagProvider({ children }: { children: React.ReactNode }) {\n  const [selectedTags, setSelectedTags] = useState<Tag[]>([]);\n  const [isPostsLoading, setPostsLoading] = useState(false);\n\n  return (\n    <TagContext.Provider\n      value={{\n        selectedTags,\n        setSelectedTags,\n        isPostsLoading,\n        setPostsLoading,\n      }}\n    >\n      {children}\n    </TagContext.Provider>\n  );\n}\n\nexport function useTagContext() {\n  const context = useContext(TagContext);\n  if (context === undefined) {\n    throw new Error(\"useTagContext must be used within a TagProvider\");\n  }\n  return context;\n}\n"],"names":[],"mappings":";;;;;;AAEA;;;AAFA;;AAYO,MAAM,2BAAa,CAAA,GAAA,6JAAA,CAAA,gBAAa,AAAD,EAAkB;IACtD,cAAc,EAAE;IAChB,iBAAiB,KAAO;IACxB,gBAAgB;IAChB,iBAAiB,KAAO;AAC1B;AAEO,SAAS,YAAY,EAAE,QAAQ,EAAiC;;IACrE,MAAM,CAAC,cAAc,gBAAgB,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAQ,AAAD,EAAS,EAAE;IAC1D,MAAM,CAAC,gBAAgB,gBAAgB,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAQ,AAAD,EAAE;IAEnD,qBACE,6LAAC,WAAW,QAAQ;QAClB,OAAO;YACL;YACA;YACA;YACA;QACF;kBAEC;;;;;;AAGP;GAhBgB;KAAA;AAkBT,SAAS;;IACd,MAAM,UAAU,CAAA,GAAA,6JAAA,CAAA,aAAU,AAAD,EAAE;IAC3B,IAAI,YAAY,WAAW;QACzB,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT;IANgB","debugId":null}},
    {"offset": {"line": 134, "column": 0}, "map": {"version":3,"sources":["file:///Users/edwin/Desktop/CSCI3100_Project/src/components/navigation/SideMenu.tsx"],"sourcesContent":["\"use client\";\nimport React, { useEffect, useState, useRef } from \"react\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\nimport { faMagnifyingGlass, faPlus } from \"@fortawesome/free-solid-svg-icons\";\nimport { getAllTags, Tag } from \"@/utils/posts\";\nimport { useTagContext } from \"@/hooks/useTags\";\nimport { usePathname } from \"next/navigation\";\nimport Link from \"next/link\";\n\nexport default function SideMenu() {\n  const { selectedTags: searchTags, setSelectedTags: setSearchTags, isPostsLoading } = useTagContext();\n  const [AllTags, setAllTags] = useState<Tag[]>([]);\n  const [recommendedTags, setRecommendedTags] = useState<Tag[]>([]);\n  // Add debounced loading state to prevent flickering\n  const [debouncedLoading, setDebouncedLoading] = useState(isPostsLoading);\n  const timerRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Debounce the loading state changes\n  useEffect(() => {\n    // When loading starts, update immediately\n    if (isPostsLoading) {\n      if (timerRef.current) {\n        clearTimeout(timerRef.current);\n        timerRef.current = null;\n      }\n      setDebouncedLoading(true);\n    } else {\n      // When loading ends, delay the update by 500ms\n      if (timerRef.current) {\n        clearTimeout(timerRef.current);\n      }\n      timerRef.current = setTimeout(() => {\n        setDebouncedLoading(false);\n      }, 500);\n    }\n\n    // Clean up\n    return () => {\n      if (timerRef.current) {\n        clearTimeout(timerRef.current);\n      }\n    };\n  }, [isPostsLoading]);\n\n  useEffect(() => {\n    getAllTags().then((tags) => {\n      setAllTags(tags);\n      setRecommendedTags(tags);\n    });\n  }, []);\n\n  const toggleTag = (tag: Tag) => {\n    if (debouncedLoading) return;\n\n    if (searchTags.some((t) => t.tagId === tag.tagId)) {\n      setSearchTags(searchTags.filter((t) => t.tagId !== tag.tagId));\n    } else {\n      setSearchTags([...searchTags, tag]);\n    }\n  };\n\n  const handleFilterTags = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const search = e.target.value.toLowerCase();\n    const filteredTags = AllTags.filter((tag) => tag.tagName.toLowerCase().includes(search));\n    setRecommendedTags(filteredTags);\n  };\n\n  const pathname = usePathname();\n  const shouldShow =\n    pathname?.includes(\"/forum/latest\") ||\n    pathname?.includes(\"/forum/recommended\") ||\n    pathname?.includes(\"/forum/search-results\") ||\n    pathname?.includes(\"/forum/following\");\n\n  if (shouldShow) {\n    return (\n      <div className=\"card bg-base-100 fixed w-77 h-full overflow-hidden\">\n        <div className=\"card-body gap-0 flex flex-col h-full\">\n          {/* Section 1 Create Post Button */}\n          <div className=\"w-full\">\n            <Link href=\"/forum/create-post\">\n              <button className=\"btn btn-primary w-full\">\n                <FontAwesomeIcon icon={faPlus} />\n                Create Post\n              </button>\n            </Link>\n          </div>\n          <div className=\"divider my-0 gap-0\"></div>\n          Filter By Tags\n          {/* Section 2 Filter and Search */}\n          <div className=\"flex flex-col sm:flex-row gap-2 justify-between flex-shrink-0\">\n            <div className=\"flex-grow w-full relative my-2\">\n              <input\n                type=\"text\"\n                placeholder=\"Search tags\"\n                className=\"w-full h-8 rounded-full bg-base-200 pl-10 pr-4 border-base-300\"\n                onChange={handleFilterTags}\n              />\n              <FontAwesomeIcon\n                icon={faMagnifyingGlass}\n                className=\"absolute left-3 top-1/2 transform -translate-y-1/2 text-base-content/60\"\n              />\n            </div>\n          </div>\n          {/* Section 3: Tags */}\n          <div className=\"scrollbar-thumb-rounded-full scrollbar-track-rounded-full scrollbar scrollbar-thumb-slate-700 scrollbar-track-slate-300 h-full overflow-y-scroll\">\n            {/* <div className=\"flex-grow overflow-y-auto min-h-0\"> */}\n            <div className=\"flex flex-wrap gap-2 p-1\">\n              {recommendedTags.map((tag) => {\n                return (\n                  <button\n                    key={tag.tagId}\n                    className={`btn btn-sm ${searchTags.some((t) => t.tagId === tag.tagId) ? \"btn-primary\" : \"btn-accent\"}`}\n                    //if debouncedLoading is true do not toggle tag\n                    onClick={() => {\n                      if (!debouncedLoading) {\n                        toggleTag(tag);\n                      }\n                    }}\n                  >\n                    {tag.tagName}\n                  </button>\n                );\n              })}\n            </div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n  else return null;\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}